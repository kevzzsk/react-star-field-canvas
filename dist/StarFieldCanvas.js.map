{"version":3,"sources":["webpack://StarFieldCanvas/webpack/bootstrap","webpack://StarFieldCanvas/./node_modules/anim-loop-engine/lib/index.js","webpack://StarFieldCanvas/./node_modules/map-number-to-range/lib/index.js","webpack://StarFieldCanvas/./src/Star.ts","webpack://StarFieldCanvas/./src/index.ts","webpack://StarFieldCanvas/./src/starColor.ts"],"names":[],"mappings":";;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qCAAqC;AACvE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;ACjDA;AAAA;AAAA;AACO;AACP;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;ACNA;AAAA;AAAA;AAAA;AAAuD;AACZ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,uDAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,sCAAsC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4EAAgB;AAC7C;AACA,sCAAsC,4EAAgB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,cAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACe;;;;;;;;;;;;;ACxGhB;AAAA;AAAA;AAAA;AAAA;AAAkD;AACpB;AACa;AAC3C;AACA;AACA;AACA;AACA,8BAA8B,WAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uDAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+DAAc;AACxC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C,gCAAgC,0CAAI;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACoB;;;;;;;;;;;;;ACtKrB;AAAA;AAAO;AACP;AACA;AACA;AACA","file":"StarFieldCanvas.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.ts\");\n","/**\r\n * Simple boilerplate avoidance class for requestAnimationFrame looping\r\n * which runs an array of tasks you specify for frame. It's not clever -\r\n * it assumes you're keeping your frame tasks fast.\r\n */\r\nexport class AnimLoopEngine {\r\n    constructor() {\r\n        this.animate = false;\r\n        this.frameReqId = 0;\r\n        this.frameTasks = [];\r\n        this.lastFrameTaskId = 0;\r\n        this.loop = (ts = 0) => {\r\n            const numTasks = this.frameTasks.length;\r\n            for (let i = 0; i < numTasks; i++) {\r\n                this.frameTasks[i].fn(ts);\r\n            }\r\n            this.frameReqId = requestAnimationFrame(this.loop);\r\n        };\r\n        this.addTasks = this.addTasks.bind(this);\r\n    }\r\n    addTask(task) {\r\n        return this.addTasks([task])[0];\r\n    }\r\n    addTasks(tasks) {\r\n        const createdIds = [];\r\n        if (tasks.length == 0) {\r\n            return createdIds;\r\n        }\r\n        tasks.forEach(task => {\r\n            this.frameTasks.push({ id: this.lastFrameTaskId, fn: task });\r\n            createdIds.push(this.lastFrameTaskId);\r\n            this.lastFrameTaskId++;\r\n        });\r\n        return createdIds;\r\n    }\r\n    deleteTask(taskId) {\r\n        this.frameTasks = this.frameTasks.filter(t => t.id !== taskId);\r\n    }\r\n    start(debugInterval) {\r\n        if (!this.animate) {\r\n            this.animate = true;\r\n            this.loop();\r\n        }\r\n    }\r\n    stop() {\r\n        cancelAnimationFrame(this.frameReqId);\r\n        this.animate = false;\r\n    }\r\n}\r\n//# sourceMappingURL=index.js.map","// Scale a number, mapping between two number ranges\r\nexport const mapNumberToRange = (input, inputRangeMin, inputRangeMax, outputRangeMin, outputRangeMax) => {\r\n    return ((input - inputRangeMin) * (outputRangeMax - outputRangeMin) /\r\n        (inputRangeMax - inputRangeMin) +\r\n        outputRangeMin);\r\n};\r\n//# sourceMappingURL=index.js.map","import { mapNumberToRange } from 'map-number-to-range';\r\nimport { defaultColor } from './starColor';\r\nvar Star = /** @class */ (function () {\r\n    function Star(opts) {\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.z = 0;\r\n        this.v = 0;\r\n        this.radius = 0;\r\n        this.lastX = 0;\r\n        this.lastY = 0;\r\n        this.splashLimitX = [0, 0];\r\n        this.splashLimitY = [0, 0];\r\n        var ctx = opts.ctx, W = opts.W, H = opts.H, hW = opts.hW, hH = opts.hH, minV = opts.minV, maxV = opts.maxV, color = opts.color, glow = opts.glow, trails = opts.trails, addTasks = opts.addTasks;\r\n        this.ctx = ctx;\r\n        this.W = W;\r\n        this.H = H;\r\n        this.hW = hW;\r\n        this.hH = hH;\r\n        this.minV = minV;\r\n        this.maxV = maxV;\r\n        this.glow = glow;\r\n        this.trails = trails;\r\n        this.color = color ? color : defaultColor;\r\n        this.splashLimitX = [-hW, hW];\r\n        this.splashLimitY = [-hH, hH];\r\n        this.addTasks = addTasks;\r\n        this.reset(true);\r\n    }\r\n    // Get the star's initial Z depth\r\n    Star.prototype.getInitialZ = function () {\r\n        return (this.W > this.H ? this.H : this.W) * 2;\r\n    };\r\n    // Calculate the star's current position star at the current\r\n    Star.prototype.draw = function (offsetX, offsetY) {\r\n        this.z -= this.v;\r\n        if (this.z <= 0) {\r\n            // Start of attempting to add bursts on \"collision\" with the viewport \r\n            // if (\r\n            //   this.lastX > this.splashLimitX[0] &&\r\n            //   this.lastX < this.splashLimitX[1] &&\r\n            //   this.lastY > this.splashLimitY[0] &&\r\n            //   this.lastY < this.splashLimitY[1]\r\n            // ) {\r\n            //   console.log(this.lastX, this.splashLimitX, this.lastY, this.splashLimitY);\r\n            //   const ex = new Explosion({ ctx: this.ctx, x: this.x, y: this.y });\r\n            //   this.addTasks([ex.draw.bind(ex)]);\r\n            // }\r\n            this.reset();\r\n        }\r\n        // Update x and y - 0.8 is an arbitrary fraction of the\r\n        var newX = this.W * (this.x / this.z) + offsetX;\r\n        var newY = this.H * (this.y / this.z) + offsetY;\r\n        // Get max Z and calc new radius/opacity based on star's position in Z range\r\n        var maxZ = this.getInitialZ();\r\n        // Calculate a new radius based on Z\r\n        var newRadius = (1 - mapNumberToRange(this.z, 0, maxZ, 0, 1)) * this.radius;\r\n        // Calculate a new opacity based on Z\r\n        var opacity = Math.round(10 - mapNumberToRange(this.z, 0, maxZ, 0, 10)) / 10;\r\n        var trailOpacity = opacity / 4;\r\n        // Draw star trail\r\n        if (this.trails && this.lastX !== this.x) {\r\n            this.ctx.lineWidth = newRadius;\r\n            this.ctx.strokeStyle = \"rgba(\" + this.color.r + \", \" + this.color.g + \", \" + this.color.b + \", \" + trailOpacity + \")\";\r\n            this.ctx.beginPath();\r\n            this.ctx.moveTo(newX, newY);\r\n            this.ctx.lineTo(this.lastX, this.lastY);\r\n            this.ctx.stroke();\r\n        }\r\n        // Save drawing settings to restore after applying the glow to stars only\r\n        if (this.glow) {\r\n            this.ctx.save();\r\n            this.ctx.shadowBlur = 5;\r\n            this.ctx.shadowColor = '#FFF';\r\n        }\r\n        // Draw the star\r\n        this.ctx.fillStyle = \"rgb(\" + this.color.r + \", \" + this.color.g + \", \" + this.color.b + \", \" + opacity + \")\";\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(newX, newY, newRadius, 0, Math.PI * 2);\r\n        this.ctx.fill();\r\n        // Undo glow settings\r\n        if (this.glow) {\r\n            this.ctx.restore();\r\n        }\r\n        // Update last x/y\r\n        this.lastX = newX;\r\n        this.lastY = newY;\r\n    };\r\n    // (Re)set the star, either initially (init) or when reaching the depth limit\r\n    Star.prototype.reset = function (init) {\r\n        if (init === void 0) { init = false; }\r\n        // Define a new random position within the canvas, velocity, and radius\r\n        this.x = Math.random() * this.W - this.hW;\r\n        this.y = Math.random() * this.H - this.hH;\r\n        this.v = Math.random() * (this.maxV - this.minV) + this.minV;\r\n        this.radius = Number((Math.random() * 2 + 1).toPrecision(3));\r\n        // Clear last x/y so we don't draw a trail from end to new reset location\r\n        this.lastX = this.x;\r\n        this.lastY = this.y;\r\n        // If not init (ie. not first run), send to furthest Z, otherwise randomize\r\n        this.z = !init ? this.getInitialZ() : Math.random() * this.getInitialZ();\r\n    };\r\n    return Star;\r\n}());\r\nexport { Star };\r\n","import { AnimLoopEngine } from 'anim-loop-engine';\r\nimport { Star } from './Star';\r\nimport { defaultColor } from './starColor';\r\n// StarField factory\r\nvar StarField = /** @class */ (function () {\r\n    function StarField(canvasId, opts) {\r\n        var _this = this;\r\n        if (opts === void 0) { opts = {}; }\r\n        this.defaultMaxV = 5;\r\n        this.defaultMinV = 2;\r\n        this.defaultNumStars = 400;\r\n        this.initialized = false;\r\n        this.canvasW = 0;\r\n        this.canvasH = 0;\r\n        this.canvasHalfW = 0;\r\n        this.canvasHalfH = 0;\r\n        this.offsetX = 0;\r\n        this.offsetY = 0;\r\n        this.offsetTX = 0;\r\n        this.offsetTY = 0;\r\n        this.stars = [];\r\n        this.resizeTimeout = 0;\r\n        if (!canvasId) {\r\n            throw 'First argument \"id\" is required';\r\n            return;\r\n        }\r\n        this.color = opts.color || defaultColor;\r\n        this.glow = opts.glow || false;\r\n        this.minV = opts.minV || this.defaultMinV;\r\n        this.maxV = opts.maxV || this.defaultMaxV;\r\n        this.numStars = this.defaultNumStars;\r\n        this.trails = opts.trails || false;\r\n        this.canvas = document.getElementById(canvasId);\r\n        this.ctx = this.canvas.getContext('2d');\r\n        var rect = this.canvas.getBoundingClientRect();\r\n        this.canvasRectLeft = rect.left;\r\n        this.canvasRectTop = rect.top;\r\n        this.handleMouseMove = this.handleMouseMove.bind(this);\r\n        // Set up animation engine\r\n        this.engine = new AnimLoopEngine();\r\n        this.engine.addTask(this.draw.bind(this));\r\n        // Set up window events\r\n        // Window blur/focus\r\n        window.addEventListener('blur', function () {\r\n            _this.stop();\r\n        });\r\n        window.addEventListener('focus', function () {\r\n            _this.start();\r\n        });\r\n        // Window event - on resize to reinitialize canvas, all stars and animation\r\n        window.addEventListener('resize', function () {\r\n            clearTimeout(_this.resizeTimeout);\r\n            _this.stop();\r\n            _this.resizeTimeout = setTimeout(function () {\r\n                _this.reset();\r\n                _this.start();\r\n            }, 500);\r\n        });\r\n        // Did config set a number of stars?\r\n        this.numStars = opts.numStars\r\n            ? Math.abs(opts.numStars)\r\n            : this.defaultNumStars;\r\n        // Setup the canvas\r\n        this.setupCanvas();\r\n        // Gen new stars\r\n        this.generateStars();\r\n        this.initialized = true;\r\n        // Did config enable mouse following?\r\n        if (opts.followMouse) {\r\n            this.setFollowMouse(true);\r\n        }\r\n    }\r\n    // Generate n new stars\r\n    StarField.prototype.generateStars = function () {\r\n        for (var i = 0; i < this.numStars; i++) {\r\n            this.stars.push(new Star({\r\n                ctx: this.ctx,\r\n                W: this.canvasW,\r\n                H: this.canvasH,\r\n                hW: this.canvasHalfW,\r\n                hH: this.canvasHalfH,\r\n                minV: this.minV,\r\n                maxV: this.maxV,\r\n                color: this.color,\r\n                glow: this.glow,\r\n                trails: this.trails,\r\n                addTasks: this.engine.addTasks\r\n            }));\r\n        }\r\n    };\r\n    // Apply canvas container size to canvas and translate origin to center\r\n    StarField.prototype.setupCanvas = function () {\r\n        var canvasStyle = window.getComputedStyle(this.canvas);\r\n        this.canvas.setAttribute('height', canvasStyle.height);\r\n        this.canvas.setAttribute('width', canvasStyle.width);\r\n        // canvasH/W/canvasHalfH/W used here and set to use elsewhere\r\n        this.canvasH = this.canvas.height;\r\n        this.canvasW = this.canvas.width;\r\n        this.canvasHalfH = this.canvasH / 2;\r\n        this.canvasHalfW = this.canvasW / 2;\r\n        this.ctx.translate(this.canvasHalfW, this.canvasHalfH);\r\n    };\r\n    // Draw the stars in this frame\r\n    StarField.prototype.draw = function () {\r\n        // Calc any mouse offsets\r\n        if (this.offsetX !== this.offsetTX) {\r\n            this.offsetX += Math.floor((this.offsetTX - this.offsetX) / 50);\r\n            this.offsetY += Math.floor((this.offsetTY - this.offsetY) / 50);\r\n        }\r\n        // Clear the canvas ready for this frame\r\n        this.ctx.clearRect(-this.canvasHalfW, -this.canvasHalfH, this.canvasW, this.canvasH);\r\n        for (var i in this.stars) {\r\n            this.stars[i].draw(this.offsetX, this.offsetY);\r\n        }\r\n    };\r\n    // Follow mouse (used in event listener definition)\r\n    StarField.prototype.handleMouseMove = function (e) {\r\n        if (this.initialized) {\r\n            this.offsetTX = e.clientX - this.canvasRectLeft - this.canvasHalfW;\r\n            this.offsetTY = e.clientY - this.canvasRectTop - this.canvasHalfH;\r\n        }\r\n    };\r\n    StarField.prototype.resetMouseOffset = function () {\r\n        this.offsetTX = 0;\r\n        this.offsetTY = 0;\r\n    };\r\n    // Start/stop the StarField\r\n    StarField.prototype.start = function () {\r\n        this.engine.start();\r\n        // this.stars.forEach(s => s.draw(0, 0))\r\n    };\r\n    StarField.prototype.stop = function () {\r\n        this.engine.stop();\r\n    };\r\n    StarField.prototype.reset = function () {\r\n        // Clear stars\r\n        this.stars = [];\r\n        // Reset canvas\r\n        this.setupCanvas();\r\n        // Gen new stars\r\n        this.generateStars();\r\n    };\r\n    // \"Hot\"-updateable config values\r\n    StarField.prototype.setMaxV = function (val) {\r\n        this.maxV = val ? Math.abs(val) : this.defaultMaxV;\r\n        this.reset();\r\n    };\r\n    StarField.prototype.setMinV = function (val) {\r\n        this.minV = val ? Math.abs(val) : this.defaultMinV;\r\n        this.reset();\r\n    };\r\n    StarField.prototype.setNumStars = function (val) {\r\n        this.numStars = val ? Math.abs(val) : this.defaultNumStars;\r\n        this.reset();\r\n    };\r\n    StarField.prototype.setFollowMouse = function (val) {\r\n        if (val) {\r\n            this.canvas.addEventListener('mousemove', this.handleMouseMove);\r\n        }\r\n        else {\r\n            this.canvas.removeEventListener('mousemove', this.handleMouseMove);\r\n            this.resetMouseOffset();\r\n        }\r\n    };\r\n    return StarField;\r\n}());\r\nexport { StarField };\r\n","export var defaultColor = {\r\n    r: 255,\r\n    b: 255,\r\n    g: 255\r\n};\r\n"],"sourceRoot":""}